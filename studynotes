2016-02-21 
Q1
STDIN_FILENO STDOUT_FILENO STDERR_FILENO和stdin stdout stderr的区别？
    前者是宏定义，在unistd.h系统库中，分别指向一个整数，也就是fd，一般系统默认对应 0 1 2；UNIX IO如read write dup2等都是用这个；
    后者是流STREAM（带缓冲区）FILE，在标准IO库中，fprintf等参数使用；

Q2
在调用dup2将标准输出重定向到文件后，使用printf或者fprintf输出，文件中不会立即出现结果？
    因为fprintf是C标准库中的，带有缓冲，所以无法立即写入，除非使用系统调用write，或者用fflush刷新；

Q3***?
在直接从chrome浏览器输入静态内容请求URI时，可能会发生第一次请求没问题，但是第二次就会出问题，使得logs.txt变得很大，且输出的都是serve_static函数里调用sprintf并用write写回客户端的内容，即本应该返回给客户端，但是却写入到了logs.txt中（但是logs.txt文件），使得logs.txt巨大而撑爆磁盘; 但是firefox浏览器却没问题？
    本以为是get_filetype处理文件类型出问题，导致返回的响应头中Content-type的MIME值和实际类型不符合，使得浏览器无法正确处理对应的文件；但是改过来后还是会随机出现该问题,可能服务器的IO处理还是不健壮

2016-02-22
Notes1
引入UNIX信号机制处理子进程回收；
    1.fork子进程时，不用wait显式的等待子进程终止，而是采用信号机制，异步的处理子进程终止时的SIGCHLD信号；
    2.如果进程捕捉信号，那么必须处理被中断的系统调用；
    3.注意SIGCHLD信号处理函数的编写，必须使用waitpid（而不是wait）避免留下僵尸进程。因为wait会因为没有收到子进程终止信号而阻塞，但是waitpid可以设置WNOHANG选项避免；

2016-02-23
续2016-02-21Q3
Q1总是出现waitpid error:no child process?
    修改了wrapper.c中的Waitpid，检测errno是否等于ECHLD;原来的版本是直接通过waitpid的返回值判断是否出错，但是仅仅是返回-1并不一定就出错，当errno没有被设置为ECHLD时，waitpid返回-1才是出错了；

2016-02-24 
Notes:建立分支，使用IO的多路复用替代多进程并发服务器
Q1:请求动态内容时，select系统调用总是被中断？
    因为父进程注册了信号处理函数，捕获了信号，导致系统调用被中断；解决办法是在设置信号的时候用SA_RESTART设置系统调用中断自重启，或者手动判断errno重启；当然还有忽略信号（让系统不产生信号中断）；不过自动重启并不是所有的系统调用都可以，依赖于不同的系统，man 7 signal查看本机上select系统调用就不支持自动重启，因此必须手动重启；
Interruption of system calls and library functions by signal handlers
       If a signal handler is invoked while a system call or library  function
       call is blocked, then either:

       * the call is automatically restarted after the signal handler returns;
         or

       * the call fails with the error EINTR.

       Which of these two  behaviors  occurs  depends  on  the  interface  and
       whether  or not the signal handler was established using the SA_RESTART
       flag (see sigaction(2)).  The details vary across UNIX systems;  below,
       the details for Linux.
    对于waitpid是自动重启的；waitpid的返回行为是：如果没有子进程后waitpid返回-1,并设置errno=ECHLD；如果waitpid若被信号中断，返回-1,并设置errno=EINTR；因此对于waitpid不用检查EINTR，但是需要检查ECHLD，因为while循环调用waitpid时，如果此时没有了子进程，Waitpid包装函数会打印unix_error并退出，因此需要检查以防止退出；
Interruption of system calls and library functions by stop signals
       On  Linux,  even  in  the  absence of signal handlers, certain blocking
       interfaces can fail with the error EINTR after the process  is  stopped
       by one of the stop signals and then resumed via SIGCONT.  This behavior
       is not sanctioned by POSIX.1, and doesn't occur on other systems.
    关于select函数的一些细节：
	1.select函数是值-结果参数，也就是参数FD_SET会被修改作为函数调用的结果，因此重复调用前必须每次重新设置FD_SET恢复
	2.select会在调用时进入内核阻塞，当有一个或者多个IO事件发生，内核就会返回结果；此时再调用系统IO也可能会阻塞，因为内核需要将数据复制到用户空间
	3.select函数的判断条件是read等系统调用的发生条件，而不是fread等带缓冲区的stdio可读写条件，stdio带有缓冲区，因此当select无法检测到条件时，stdio中可能还有数据未读取；因此混合使用select和stdio不被建议；

2016-02-25
Notes:建立分支，使用多线程并发服务器
Q1:出现Broken pipe错误？
    对一个对端已经关闭的socket调用两次write, 第二次将会生成SIGPIPE信号, 该信号默认结束进程.具体的分析可以结合TCP的"四次握手"关闭. TCP是全双工的信道, 可以看作两条单工信道, TCP连接两端的两个端点各负责一条. 当对端调用close时, 虽然本意是关闭整个两条信道, 但本端只是收到FIN包. 按照TCP协议的语义, 表示对端只是关闭了其所负责的那一条单工信道, 仍然可以继续接收数据. 也就是说, 因为TCP协议的限制, 一个端点无法获知对端的socket是调用了close还是shutdown.对一个已经收到FIN包的socket调用read方法, 如果接收缓冲已空, 则返回0, 这就是常说的表示连接关闭. 但第一次对其调用write方法时, 如果发送缓冲没问题, 会返回正确写入(发送). 但发送的报文会导致对端发送RST报文, 因为对端的socket已经调用了close, 完全关闭, 既不发送, 也不接收数据. 所以, 第二次调用write方法(假设在收到RST之后), 会生成SIGPIPE信号, 导致进程退出.
    因此需要捕获并处理该信号，同时查看write系统调用是否有EPIPE错误；

